import s from "sbor-ez-mode";
// Generated TypeScript schema for Scrypto SBOR types of package address: package_rdx1p4dhfl7qwthqqu6p2267m5nedlqnzdvfxdl6q7h8g85dflx8n06p93
// Generated by: https://www.8arms1goal.com/sbor-ez-mode-ez-mode

export const NonFungibleGlobalId = s.struct({
  resource_address: s.address(),
  local_id: s.nonFungibleLocalId(),
});

export const ResourceOrNonFungible = s.enum([
  { variant: "NonFungible", schema: s.tuple([NonFungibleGlobalId]) },
  { variant: "Resource", schema: s.tuple([NonFungibleGlobalId]) },
]);

export const TokenDeBlacklisted = s.struct({
  token: s.address(),
});

export const PairRelisted = s.struct({
  token: s.address(),
  pair: s.address(),
});

export const TokenDeListed = s.struct({
  base_token: s.address(),
  component: s.address(),
});

export const TokenBlacklisted = s.struct({
  token: s.address(),
});

export const Shortage = s.enum([
  { variant: "BaseShortage", schema: s.tuple([]) },
  { variant: "Equilibrium", schema: s.tuple([]) },
  { variant: "QuoteShortage", schema: s.tuple([]) },
]);

export const ProofRule = s.enum([
  { variant: "Require", schema: s.tuple([ResourceOrNonFungible]) },
  { variant: "AmountOf", schema: s.tuple([ResourceOrNonFungible]) },
  { variant: "CountOf", schema: s.tuple([ResourceOrNonFungible]) },
  { variant: "AllOf", schema: s.tuple([ResourceOrNonFungible]) },
  { variant: "AnyOf", schema: s.tuple([ResourceOrNonFungible]) },
]);

export const AccessRuleNode = s.enum([
  { variant: "ProofRule", schema: s.tuple([ProofRule]) },
  { variant: "AnyOf", schema: s.tuple([ProofRule]) },
  { variant: "AllOf", schema: s.tuple([ProofRule]) },
]);

export const AccessRule = s.enum([
  { variant: "AllowAll", schema: s.tuple([]) },
  { variant: "DenyAll", schema: s.tuple([]) },
  { variant: "Protected", schema: s.tuple([]) },
]);

export const OwnerRole = s.enum([
  { variant: "None", schema: s.tuple([]) },
  { variant: "Fixed", schema: s.tuple([]) },
  { variant: "Updatable", schema: s.tuple([]) },
]);

export const PlazaDex = s.struct({
  dfp2: s.address(),
  blacklist: s.array(s.address()),
  address_to_pair: s.internalAddress(),
  pair_to_lps: s.internalAddress(),
  dex_reserves: s.internalAddress(),
  min_dfp2_liquidity: s.decimal(),
  pairs_owner: OwnerRole,
});

export const PairState = s.struct({
  p0: s.decimal(),
  shortage: Shortage,
  target_ratio: s.decimal(),
  last_outgoing: s.number(),
  last_out_spot: s.decimal(),
});

export const PairConfig = s.struct({
  k_in: s.decimal(),
  k_out: s.decimal(),
  fee: s.decimal(),
  decay_factor: s.decimal(),
});

export const PairCreated = s.struct({
  base_token: s.address(),
  config: PairConfig,
  p0: s.decimal(),
  component: s.address(),
});

export const PlazaPair = s.struct({
  config: PairConfig,
  state: PairState,
  base_address: s.address(),
  quote_address: s.address(),
  base_divisibility: s.number(),
  quote_divisibility: s.number(),
  base_pool: s.address(),
  quote_pool: s.address(),
});

export const SwapEvent = s.struct({
  base_amount: s.decimal(),
  quote_amount: s.decimal(),
});

export const AddLiquidityEvent = s.struct({
  is_quote: s.bool(),
  token_amount: s.decimal(),
  lp_amount: s.decimal(),
});

export const RemoveLiquidityEvent = s.struct({
  is_quote: s.bool(),
  main_amount: s.decimal(),
  other_amount: s.decimal(),
  lp_amount: s.decimal(),
});

export type SwapEvent = s.infer<typeof SwapEvent>;
export type AddLiquidityEvent = s.infer<typeof AddLiquidityEvent>;
export type RemoveLiquidityEvent = s.infer<typeof RemoveLiquidityEvent>;
